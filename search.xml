<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我思故我在]]></title>
    <url>%2F2016%2F11%2F26%2F%E6%88%91%E6%80%9D%E6%95%85%E6%88%91%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[我借用了笛卡尔在他的《方法论》中提及的“我思故我在（Cogito, ergo sum）”的理论来构建此文的标题，但是我们将要讨论的问题并不仅仅是“我”这个概念的阐述（实际上这实在是一个难以阐述的问题，似乎难以找到一个很准确的定义可以用来描述我，并依此使我和其他任何事物有不同的可以认知的区别）。我将要讨论的是：在我存在的情况下，我所能看到的我所在的这个世界是怎么样的。 第一个问题，我存在吗？先看一个合理的假设吧。在未来有一位科学家（不管他是否拥有真实存在的肉体和灵魂）做了一个实验。实验的内容是，他将很多大脑通过某种作用联系在一起，当然这些大脑都是活的。并且他使得这些大脑都认为自己存在一个相对于科学家虚拟出的合理的世界中。也就是说，这些大脑认为自己是自然人，并且能够感受到自己的肉体，能够触碰和使用他们所在世界的每一个物体，那个虚拟出的世界和当前世界没有任何区别。好了，这个假设构建完了。那么，对于科学家来说，那个世界中的人是否是存在的？（他们包含了肉体和灵魂吗？）对他们自己来说呢？那个“我”是否存在？笛卡尔的“二元论”如是说：“宇宙间共有两种不同形式的真实世界（或称‘实体’）。一种实体称为思想或‘灵魂’，另一种则称为‘延扩’（Extension），或称物质。”此外，我们还必须接受一个观点，没有任何事物（或者思想）是可以凭空冒出的，也就是说事物（或者思想）必有一个前因，它们因前一事物（或者思想）演化而来。那么上述假设中，对于那个世界的“我”来说，“我”是否存在？可以如此论证：首先，不论对于哪个世界的我来说，我能思考是确定的事实；其次我能看到我类似于物质的存在。因此在某个或这个世界中一定有一个真实的思考，由这个思考引发了现在我认识到的我的思考，（引发。）另外在某个或这个世界中一定有个真实的物质，它以某种投射关系引发了我这个物质。（引发。）也就是说，当我能够思考时，在思想（灵魂）上我是真实存在的；（一元。）当我能够看到我作为物质时，在物质上我是真实存在的。（一元。）在一方面，我看到我作为了物质，实际上也能够证明我在感官上是有认知，可以思考的。因此对于上述问题，我们能够做出解答，不论对于那个世界的“我”来说，当我能够问出“我存在吗？”之类的问题的时候我一定是真实存在的。上述假设中，对与科学家来说，那个世界的人存在吗？可以如此论证：能确定的是，我们无法看到那个世界的人，也无法知晓他们是否具有思考的能力（实际上对我们能够“看到”的其他任何人也一样）。但是引发了那个世界人类的大脑们和构造了那个世界的某种物质（比如计算机）我们是可以看到的。同样根据之前的理论，我们知道我们看到的这些大脑、计算机等一定是由真实的物质的通过某种投影得来的。（引发。）也就是说，我无法知晓那个虚拟的世界，但是我能看到（感知到）那个世界的真实物质（请注意，只包含了物质）在我这个世界中的投影。（一元。）我能够确定那个世界的物质是真实存在的。因此，可以得出结论“我思故我在”（二元的存在），而对于我们“看到”的其他事物，能够确信的是有一个对应的真实的物质是存在的（至少是一元的存在）。尽管可能和我们常以为的有点出入，但这并不是荒谬的。 第二个问题，我是我吗？ 这个问题可以通俗的阐释为：我看到的我，或者了解到的我，或者我看到的、了解到的其他是不是正如我看到的这样的呢？同样，我们来看一个合理的假设。有一种这样的生物，它生活在山洞里，看不到外面的世界，它也不知道有一个外面的世界。山洞里除了墙壁只有阳光投射过来的山洞外事物的影子。比如说树的影子啊，蝴蝶的影子啊，等等。对于他们来说，他们的世界就是各种各样的影子组成的。有几个需要承认的事实是：人的感官是不准确的，并且富有较强的主观色彩；人是一种经验主义的动物，难以做到以“纯粹理性”来思考和感知世界。一个合理的猜测就是我们的世界似乎就是这样的。我们看到的事物就是我们看到的样子吗？在此处暂且不论事物的变化导致的情况。我认同这种“我们世界是另外一个真实世界的投影”这种说法。我们所见到的所有事物不过是真实事物的投影罢了。但是我可以将我们所见的事物定义为确实存在的，这种存在是在另一个理性上的真实的世界中的真实的存在，尽管在这里它可能只是一个投影，但总归可以通过这个影子追溯到它原本的真实的存在。按照上面的假设来说，如果这种生物的“延伸”足够长，他将突破他的世界的束缚，因此将有可能知道他的世界将是另外一个世界中存在的事物的投影，或者它能够凭借它的不准确的感官感知这些真实的存在而非投影。由我们的经验主义决定，我们大多数是会通过对某个事物的历史总结来完善的，并且在思想的空间里会构建我们自己定义的事物。比如说，我看到过很多的马，在此时此刻我想到了马。那么我想的这匹马是不是存在的呢？它是怎么样的呢？按照第一个问题的论述，我们可以肯定，即使是一匹我们想象到的马，它也是存在的。它存在于我的思想空间中，它是由我见过的很多马共同通过我的在思考上的某种作用而生成的；另外它也存在于我见过的所有马的身上。但是它却不同于我见过的任何一匹马，和我思想空间中的马也是有区别的。（我思想空间中的马可以和我知道的所有的马匹配，但是我现在想到的马有特定的可以表述的唯一的特征，两者显然是不一样的。）综上所述，我们看到的事物或者是思考到的事物和真实存在的是有区别的，但总归有某些共性，找到理性上真实存在的确定的事物是难以达到的。这也解释了第一个问题中的疑问，我思故我在，但是真实存在的我和我现在了解到的（看到的）我是不一样的，这个真实的我可能只是一个大脑、一台计算机。我甚至无法从我所在的这个世界来确定真实的我是以何种形式存在的。 最后一个问题，这个世界是怎样的？ 这已无需过多的阐述了，根据上面两个问题的论据和结论我们可以对这个问题作出以下解释：首先，我能够思考，故而我是存在的；其次，我是存在的这一事实将使得我能够了解我现在存在的这个世界；再其次，尽管我的感官受限，不准确，但是通过它们我能够确定我所在的这个世界的一切我能认知的事物是存在的；再其次，受限的感官和经验性使得我确认的存在和真实的存在是有区别的，但是也包含共性。最后，可以得出的结论是，在我确认我存在的情况下，我所在的这个世界的我已认知的一切事物都是存在的，其真实面貌和我认知的是同异共存的。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>自我</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一份Node.js代码]]></title>
    <url>%2F2016%2F07%2F19%2F%E7%AC%AC%E4%B8%80%E4%BB%BDNode-js%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一起学习吧！第一讲先介绍如何搭建一个很基础的http服务器，当然既然使用node.js，我们至少也要有js的基础知识。准备node.js是一种可以在后台运行的js代码，既然如此我们也需要一种类似浏览器的js解释器来运行后台代码–这就是NODE.JS。实际上它既是一个运行环境，也像jquery这样提供了一个强大的库。所以，node.js的前期工作就是安装好它。安装很简单，记住让他自己配置好环境变量就行。（你一定不愿意再花时间找配置文件改吧）附上链接：nodejs.org著名的“HELLO WORLD”哈哈哈，有看到了著名的hello world程序！但是这次我们做高级一点，还是先贴代码吧：var http=require(“http”);http.createServer(function(request,response){ response.writeHead(200,{“Content-Type”:”text/plain”}); response.write(“HELLO WORLD”); response.end();}).listen(8888);怎么样？看起来很简单，结构也很熟悉对吧。把它保存为server.js，解释之……第一行看字面意思就知道了吧，请求了http模块，并把它“赋值”http变量。学过python的是不是很有熟悉感？第二行createServer函数的实参是一个函数，神奇？！在js中，这是可行的。之后就是发送报头&gt;&gt;&gt;输出&gt;&gt;&gt;结束。整个createServer函数监听8888端口。命令行下运行node server.js，浏览器访问127.0.0.1:8888就有结果了。 先看一份代码: var http=require("http"); var url=require("url"); function onRequest(request,response) { var pathname=url.parse(request.url).pathname; console.log(pathname+" Received"); response.writeHead(200,{"Content-type":"text/plain"}); response.write("HELLO WORLD"); response.end(); } http.createServer(onRequest).listen(8888); console.log("Started"); 函数式编程风格！ 这次用到了url模块，它有哪些功能不做介绍，看名字就知道。另，较之上一篇，这里用到了request这个参数了。顾名思义，用户发送的所有请求都包含在request对象中。而这里用到了request.url,获取请求路径。各API参考文档如果你有运行（命令行 node server.js）这段代码就发现，会先在终端窗口打印“Started”，待浏览器请求127.0.0.1:8888的时候，再会打印“/ Received \n /favicon.ico Received”。不过联想到之前讲到过的ajax，这东西还真是这么回事。那么，怎么解释呢？看看官网上的一句话“Node.js uses an event-driven, non-blocking I/O model”–“Node.js使用事件驱动、非阻塞式I/O模型”。不管前面怎么说，看到“非阻塞”就应该明白了吧。非阻塞]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑期社会纪实]]></title>
    <url>%2F2016%2F07%2F15%2F%E6%9A%91%E6%9C%9F%E7%A4%BE%E4%BC%9A%E7%BA%AA%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[从7.12到18号将进行为期几天的社会实践活动，期间，可能是由于年龄以及历史积累的关系，对所见所闻总是很有感触，现在即记录之，记录文字尽量删除了我的情感元素，只确保不同时期看是不被我暂时的情感影响。跳至末尾 DAY ONE到南昌西站，因为是外地人，对我们对外人总是有一种戒心，至少对我来说，有感到害怕。对拉我们坐车的司机一概不理会。坐长途汽车去旅馆所在地。提有大型行李的旅客把行李放在车底，路途上汽车停车若干次。每遇有人下车，车上旅客便会盯紧自己的行李，我无法解释是因为害怕行李被拿错还是被拿走。入住酒店后，吃午饭。找到一家“黄焖鸡米饭”，点菜。前后两份肉末茄子，待食第二份时，才发现第一份上菜时的温度低得多，而且茄子造型与第二份明显不同，没有证据，我无法解释为何如此，但是之后有若干同学肚子痛。晚饭，店家少收我们一个零头的钱。 DAY TWO午饭，店家少收我们一个零头的饭钱，因为有零钱，我们补上。下午车站取票，遇一小孩卖水，并挂写有“勤工俭学”的牌子，但小孩明显有不自然感，同时，小孩正对面坐有一大人，与小孩无交谈。取票回来，小孩与大人都离开了。在南昌遇到了一些乞讨的老人，手脚健全，行动相对自如。火车站见若干卖水老人，外表如历尽沧桑，上了年纪。还有两位同是卖水老人相互笑着交谈，其一还指着人多的一处。晚饭，带队友吃南昌粉。我与另一位同学点一鸡蛋炒粉，我觉得口感不对，以为只是店家手艺不行，待另外同学再吃时，我尝尝，才发现我那一碗是凉的，而且粉是滑的。店家算账与我们所算不符，店家少算3元，我们补上。晚饭时，下暴雨。冒雨回酒店，路遇小超市，进去买东西，出来时，店家提醒我们小心，还给一个袋子保护钱包手机等财物。 DAY THREE上车。车上遇一年轻女士读书，气质极佳。而后另一妇女坐我旁边。若干站后，另一乘客表示此位置是他的，妇女辩解我也是9号啊，我一看车票她是90号。我以为她看错，说明之，妇女惊讶，但并无让座之意，此事不了了之。车上，对面坐一中年妇女，而后知晓其为景德镇某陶瓷店老板。她在车上给我们讲了很多话，告诉我们在景德镇要怎么怎么小心，不要被骗了，注意安全啊等等。此人心地甚是善良，但是，下车之时我们并没有道谢，至今仍感惭愧。 DAY FOUR上午去陶瓷艺术博览区，买学生票，进门保安检票，同时检查学生证，并表示只是应付领导，所以只是看看有没有证件。游览期间采访了陶瓷艺人若干，皆为老人，回答都很用心。其中一位老人在我们要求合影时还略显羞涩。我们所见陶瓷艺人掌握技艺都有几十年的时间，甚为努力。游览期间，有一妇女向我们请求借5张门票，未表原因，我们未借。中午乘公交会酒店，拦错车，司机无愠颜并给我们指引。下午坐公交之前打算打车，出租车司机表示一般不打表，直接开价，我们见公交来后直接离开。到达目的地，未见博览馆，问及以为坐在旁边的中年人，回答随意，只叫我们自己看看旁边，而亦未找到。 DAY FIVE下午去博物馆，坐公交坐到了终点站，司机告诉我们坐过头了，继续送我们到目的地，未再收钱。参观后回酒店，公交车站与另一乘客交换零钱，一起上车后在目的地他提醒我们下车，但是已经错过站了。回来路上遇到一个混混，挑衅我们，让我们不要挡道，并出言不逊。 DAY SIX无事记 DAY SEVEN最后一天，坐车回家。车上遇一人看视频放外音，声音极大，吃泡面的人也不在少数。从南昌到萍乡路上遇一对小孩（姐姐和妹妹），对话甚是有趣，充满童真。姐姐也有姐姐的样子–教育妹妹 一些感触出过的远门也相对不少了，这是第一次全程都只有小伙伴的陪同，再也没有我的长辈们的保护了。对所见也有很深很新的感触。就现在一般来说，我常常会对这个社会有种奇特的看法。我所在的环境一点也不安全，一不小心可能就要被人欺负（其实，为什么我会怕被人欺负呢？）。但是在家里我是安全的，为什么同在江西，同为中国人，同是人类我却要对其他人感到恐惧？就现在的经历，我不知道是我变了（社会一直这样）还是大家变了（我心胸狭隘了），至少在我小时候在记忆中从未对陌生的环境有如此般的恐惧心理。或许，当我有了小孩，当我可以像我父母爱我一样爱我的小孩的时候，我就会知道我看到的社会到底是怎么样的。尽管现在的我对我所在的社会是如此的不安，还是总有一些事是能感动我的。特别是那位在火车上教我们注意安全的阿姨，不仅仅是热心，我觉得也有对我们初入社会的人的爱心。还有卖水的老奶奶们，她们让我想到了我的外婆，一把年纪了，却还要劳累。她们的一生都可能没有过像我们现在这样的享受时光。不知是人类的弱点还是只是我的原因，常常让我想起的一定不是人类的光辉，而是我见到的罪恶。我姐姐曾经对我说过的一句话，我会永远记得她的意思“不管你以后看到的社会是怎样，一定不要对它失望！”]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>社会</tag>
        <tag>感触</tag>
        <tag>见闻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端实现2048游戏]]></title>
    <url>%2F2016%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B02048%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[这个小游戏写了大概有半年了吧，现在拿出来讲一讲。源码请看github仓库 不过没有分离代码，就把所有代码都挤在一堆了…2048游戏链接 先来分析分析2048的结构。之后再会讲到怎么用js代码实现。 上图先注意到有12个小方格用来容纳数字，小方格的样式容易写吧，就不赘述了。而且方格数目是不变的，那么这里直接用12个div容器也未尝不可。我的布局方式是大容器包含12个方格，中等的容器包含了一行的4个方格，这样写只是为了读取的时候方便一点。贴一份标签吧：（贴标签有点麻烦，还是上图吧）之后就是操作按钮了（简单，就不说了），愿意的话可以尝试用js触控事件来写，这样就更接近移动端APP 刚开始写的时候，布局并不是很熟练。又不想给每个放数字的容器都规定一个位置，实在是太麻烦re…如果把每行都放在一个容器里面，操作起来就简单多了（只需对行操作，行里面的元素加margin就行）。但是！！！我虽然是这样布局div的，之后看代码才发现，我竟然用js来定位，实在不符合“结构”“表示”“行为”分离这一原则。 OK，布局就先到这了 初始化注意到每次运行2048在16个方格中随机两个方格就会出现2或4。这里的随机用伪随机就可以了，取0~15两个不同的随机数（方格），再随机把2或4填入方格。(这个就不贴代码了) 移动逻辑下面是数字向左移动的一段代码，先移动，再计算，再移动 i=1;n=1;var flag=Array(6);for(n=1;n&lt;5;n++){ cellValue=cell[n-1].firstChild.nodeValue; if(cellValue==” “){flag[i]=1;i++;}else{flag[i]=0;i++;}; //对第一行，如果方格的内容为空，相关旗帜标记为1，否则为0}for(count=1;count&lt;15;count++) for(i=1;i&lt;5;i++) { if((flag[i]!=0)&amp;&amp;(flag[i+1]==0)) //前一个方格内容为空后一个方格有内容，则将后一个方格数字移动到前一个，并清空后一个方格内容 { cell[i-1].firstChild.nodeValue=cell[i].firstChild.nodeValue; cell[i].firstChild.nodeValue=” “; flag[i+1]=1; flag[i]=0; } }for(m=1;m&lt;4;m++){ if((cell[m-1].firstChild.nodeValue==cell[m].firstChild.nodeValue)&amp;&amp;(cell[m-1].firstChild.nodeValue!=” “)){cell[m-1].firstChild.nodeValue=cell[m-1].firstChild.nodeValue*2;cell[m].firstChild.nodeValue=” “;} //前后方格内容相同，则前一个方格内容值加倍，后一个方格清空，且保证所有相邻数字已相加}i=1;n=1;//继续移动var flag=Array(6);for(n=1;n&lt;5;n++){ cellValue=cell[n-1].firstChild.nodeValue; if(cellValue==” “){flag[i]=1;i++;}else{flag[i]=0;i++;};}for(count=1;count&lt;15;count++) for(i=1;i&lt;5;i++) { if((flag[i]!=0)&amp;&amp;(flag[i+1]==0)) { cell[i-1].firstChild.nodeValue=cell[i].firstChild.nodeValue; cell[i].firstChild.nodeValue=” “; flag[i+1]=1; flag[i]=0; } }对每个方向的移动做成函数，在键盘控制或触摸控制中调用就好了。因为代码没有做优化，所以又臭又长。每个方向的移动对每一行（列）应该都可以放在一个大循环里面。不过即使是解释性语言，对这一点计算量而言，执行起来还是很快的。另外，在每次数字移动的时候还可以加上动画，这样移动就不会显得这么难看。 生成新数每次移动后，都要在一个空方格内生成2或4。我们可以在移动完成后，遍历所有方格，找到内容为空的随机取一个方格再随机填2、4就好了。 输赢判断遍历16个方格，2048是否出现，再看看有没有空格，相邻方格内容是否相同。这个还是比较好写的。 键值获取window.onkeydown=function(e){ e=e||window.event; var code=e.which||e.keycode; alert(code);}看看alert出来的结果是什么就好了 总结初始化→→→获取键值→→→移动→→→输赢判断→→→生成新数]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>2048</tag>
        <tag>游戏</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
